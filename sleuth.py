#!/usr/bin/env python3
import argparse
import sys
import socket
import concurrent.futures
from datetime import datetime

# --- Configuration ---
VERSION = "1.5.0-Final"
TOOL_NAME = "Cyber Sleuth Toolkit"
MAX_THREADS = 50

# --- Global Storage for Report ---
scan_results = []
subdomain_results = []
header_results = []
whois_data = "No WHOIS data requested."

SUBDOMAINS = [
    "www", "mail", "ftp", "localhost", "webmail", "smtp", "pop", "ns1", "ns2",
    "test", "dev", "admin", "forum", "blog", "vpn", "secure", "shop", "api"
]

def banner():
    print(f"""
    ===========================================
      {TOOL_NAME} v{VERSION}
      created by Liberty Kondo
    ===========================================
    """)

# --- Module: HTML Reporting ---
def generate_html_report(filename, target):
    print(f"\n[*] Generating HTML Report: {filename}...")
    
    # Check if we have data to avoid empty tables
    sub_content = "".join([f"<li>{s}</li>" for s in subdomain_results]) if subdomain_results else "<li>No subdomains found or scan not run.</li>"
    
    html_content = f"""
    <html>
    <head>
        <title>{TOOL_NAME} Report - {target}</title>
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f4f4f4; color: #333; line-height: 1.6; }}
            .container {{ width: 90%; max-width: 1000px; margin: 20px auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.1); }}
            h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
            h2 {{ color: #2c3e50; margin-top: 30px; border-left: 5px solid #e67e22; padding-left: 10px; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }}
            th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
            th {{ background-color: #2c3e50; color: white; }}
            tr:nth-child(even) {{ background-color: #f9f9f9; }}
            .missing {{ color: #e74c3c; font-weight: bold; background-color: #fadbd8; }}
            .present {{ color: #27ae60; font-weight: bold; background-color: #d5f5e3; }}
            pre {{ background: #eee; padding: 15px; overflow-x: auto; border-radius: 5px; border: 1px solid #ccc; }}
            .footer {{ margin-top: 50px; font-size: 0.8em; color: #777; text-align: center; border-top: 1px solid #eee; padding-top: 20px; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Cyber Sleuth Security Report</h1>
            <p><strong>Target:</strong> {target}<br>
            <strong>Scan Date:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            
            <h2>1. Port Scan Results</h2>
            <table>
                <tr><th>Port</th><th>Status</th><th>Service Banner</th></tr>
                {"".join([f"<tr><td>{r['port']}</td><td>OPEN</td><td>{r['banner']}</td></tr>" for r in scan_results])}
            </table>
            
            <h2>2. HTTP Security Headers</h2>
            <table>
                <tr><th>Header</th><th>Status</th><th>Value</th></tr>
                {"".join([f"<tr><td>{h['header']}</td><td class='{h['status_class']}'>{h['status']}</td><td>{h['value']}</td></tr>" for h in header_results])}
            </table>
            
            <h2>3. Subdomains Discovered</h2>
            <ul>
                {sub_content}
            </ul>

            <h2>4. WHOIS Information</h2>
            <pre>{whois_data[:2000] + ("..." if len(whois_data) > 2000 else "")}</pre>

            <div class="footer">Generated by Cyber Sleuth Toolkit v{VERSION}</div>
        </div>
    </body>
    </html>
    """
    
    try:
        with open(filename, "w") as f:
            f.write(html_content)
        print(f"[+] Report saved to {filename}")
    except Exception as e:
        print(f"[!] Error saving report: {e}")

# --- Module: Header Analysis ---
def analyze_headers(target):
    print(f"\n[*] Analyzing HTTP Headers for {target}...")
    required_headers = ["X-Frame-Options", "Content-Security-Policy", "Strict-Transport-Security", "X-Content-Type-Options", "Referrer-Policy"]
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(3)
        ip = socket.gethostbyname(target)
        s.connect((ip, 80))
        s.send(f"HEAD / HTTP/1.0\r\nHost: {target}\r\n\r\n".encode())
        response = s.recv(4096).decode('utf-8', errors='ignore')
        s.close()
        
        headers_found = {}
        for line in response.splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                headers_found[key.strip().lower()] = value.strip()
        
        for req in required_headers:
            if req.lower() in headers_found:
                val = headers_found[req.lower()]
                print(f"[+] {req}: PRESENT")
                header_results.append({"header": req, "status": "PRESENT", "status_class": "present", "value": val[:50]})
            else:
                print(f"[-] {req}: MISSING")
                header_results.append({"header": req, "status": "MISSING", "status_class": "missing", "value": "N/A"})
    except Exception as e:
        print(f"[!] Failed to fetch headers: {e}")

# --- Module: Subdomains ---
def check_subdomain(domain, sub):
    sub_domain = f"{sub}.{domain}"
    try:
        ip = socket.gethostbyname(sub_domain)
        return sub_domain, ip
    except:
        return None, None

def enum_subdomains(domain):
    print(f"\n[*] Enumerating Subdomains for {domain}...")
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
        future_to_sub = {executor.submit(check_subdomain, domain, sub): sub for sub in SUBDOMAINS}
        for future in concurrent.futures.as_completed(future_to_sub):
            sub, ip = future.result()
            if sub:
                print(f"[+] Found: {sub} -> {ip}")
                subdomain_results.append(f"{sub} ({ip})")

# --- Module: WHOIS ---
def perform_whois_query(server, domain):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((server, 43))
        s.send(f"{domain}\r\n".encode())
        response = ""
        while True:
            data = s.recv(4096)
            if not data: break
            response += data.decode('utf-8', errors='ignore')
        s.close()
        return response
    except:
        return ""

def get_whois(domain):
    global whois_data
    print(f"\n[*] Performing WHOIS lookup for {domain}...")
    iana = perform_whois_query("whois.iana.org", domain)
    referral = None
    for line in iana.splitlines():
        if "refer:" in line:
            referral = line.split(":")[-1].strip()
            break
    
    if referral:
        print(f"[*] Redirecting to registrar: {referral}")
        whois_data = perform_whois_query(referral, domain)
    else:
        whois_data = iana
    print("[+] WHOIS Data retrieved.")

# --- Module: Port Scanner ---
def check_port(target_ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((target_ip, port))
        if result == 0:
            try:
                sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
                banner = sock.recv(1024).decode().strip()
                return port, True, banner
            except:
                return port, True, "Unknown Service"
        sock.close()
    except:
        pass
    return port, False, None

def scan_ports(target, ports):
    print(f"\n[*] Starting Port Scan on {target}...")
    try:
        target_ip = socket.gethostbyname(target)
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
            future_to_port = {executor.submit(check_port, target_ip, port): port for port in ports}
            for future in concurrent.futures.as_completed(future_to_port):
                port, is_open, banner_data = future.result()
                if is_open:
                    print(f"[+] Port {port}: OPEN")
                    scan_results.append({"port": port, "banner": banner_data})
    except:
        print("[!] Could not resolve hostname.")

# --- Main ---
def main():
    banner()
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", help="Target Domain", required=True)
    parser.add_argument("-p", "--ports", help="Ports (e.g. 20-100)", default="20-100")
    parser.add_argument("--html", help="Generate HTML Report filename")
    parser.add_argument("--full", action="store_true", help="Run ALL scans (Ports, Headers, Subdomains, WHOIS)")
    args = parser.parse_args()
    
    # 1. Port Scan (Always runs)
    port_list = []
    if '-' in args.ports:
        start, end = map(int, args.ports.split('-'))
        port_list = range(start, end + 1)
    else:
        port_list = [int(p) for p in args.ports.split(',')]
    scan_ports(args.target, port_list)

    # 2. Header Analysis (Always runs)
    analyze_headers(args.target)

    # 3. Optional Modules (Run if --full is used)
    if args.full:
        enum_subdomains(args.target)
        get_whois(args.target)
    
    # 4. Generate Report
    if args.html:
        generate_html_report(args.html, args.target)

if __name__ == "__main__":
    main()

